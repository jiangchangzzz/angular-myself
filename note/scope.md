# Scope And Digest

1.$digest如果是第一次运行，所有的监视数据都会改变，所有数据都是脏的，还会再循环一次，直到没有一个监视数据改变，同时到达一种稳定状态。

2.如果两个监听函数互相改变对方的数据，则状态永远都不会稳定，因此要给脏检查循环次数设置一个上限，一般为10次，在angular中这个上限是可以设置的。

3.优化脏检查循环，每次循环记录下上一个脏的监视器，下次循环时如果这个监视器干净了，就不在继续检查后面的监视器了，后面的监视器肯定也都是干净的，不可能被改变了。

4.用了脏检查优化后，如果在一个监听函数中添加一个新的监视器，下一次脏检查循环可能就不会运行这个新的监视器，需要在添加了新的监视器以后，禁止脏检查优化。**注意**：旧值是存放在监视器中，监视同一个数据的监视器可能旧值不同。

5.$watch函数添加一个可选的参数flag，表示是否要基于值来比较新值和旧值，只有发生了变化才会调用监听函数。同时保存旧值得时候也要保存旧值的深度拷贝。**注意**：NaN是不等于NaN本身的，需要单独比较。

6.$eval函数，可以让一个函数在scope上下文环境中执行，即将scope作为参数传递给它。它最大的用途就是能够执行在scope上下文中执行表达式。

7.$apply函数，可以用于集成外部代码，可以在外部调用脏检查循环。将脏检查循环包裹在finally中确保脏检查循环一定可以执行。

8.$evalAsync函数，可以用于在监听函数中延时执行函数，延时函数将在下一次脏检查循环之前过程中执行，主要用于防止浏览器不必要的渲染，可以在所有代码执行完后，再进行浏览器渲染。

9.确保$evalAsync函数在watchFn中运行正常，如果监视器都不是脏的，则不会进行下一次脏检查循环，也就不会运行已注册的延时运行函数。同时，如果$evalAsync总是在watchFn中被调用，那么异步队列总不为空，脏检查循环次数达到上限后，需要抛出异常。

10.$evalAsync异步运行函数，需要检查当前的状态，是否脏检查循环已经开始运行，如果没有运行的话就要开始脏检查循环，以便可以尽快运行异步函数，因此，需要给scope一个状态量$$phase.