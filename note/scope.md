# Scope And Digest

1.$digest如果是第一次运行，所有的监视数据都会改变，所有数据都是脏的，还会再循环一次，直到没有一个监视数据改变，同时到达一种稳定状态。

2.如果两个监听函数互相改变对方的数据，则状态永远都不会稳定，因此要给脏检查循环次数设置一个上限，一般为10次，在angular中这个上限是可以设置的。

3.优化脏检查循环，每次循环记录下上一个脏的监视器，下次循环时如果这个监视器干净了，就不在继续检查后面的监视器了，后面的监视器肯定也都是干净的，不可能被改变了。

4.用了脏检查优化后，如果在一个监听函数中添加一个新的监视器，下一次脏检查循环可能就不会运行这个新的监视器，需要在添加了新的监视器以后，禁止脏检查优化。**注意**：旧值是存放在监视器中，监视同一个数据的监视器可能旧值不同。

5.$watch函数添加一个可选的参数flag，表示是否要基于值来比较新值和旧值，只有发生了变化才会调用监听函数。同时保存旧值得时候也要保存旧值的深度拷贝。**注意**：NaN是不等于NaN本身的，需要单独比较。

6.$eval函数，可以让一个函数在scope上下文环境中执行，即将scope作为参数传递给它。它最大的用途就是能够执行在scope上下文中执行表达式。

7.$apply函数，可以用于集成外部代码，可以在外部调用脏检查循环。将脏检查循环包裹在finally中确保脏检查循环一定可以执行。

8.$evalAsync函数，可以用于在监听函数中延时执行函数，延时函数将在下一次脏检查循环之前过程中执行，主要用于防止浏览器不必要的渲染，可以在所有代码执行完后，再进行浏览器渲染。

9.确保$evalAsync函数在watchFn中运行正常，如果监视器都不是脏的，则不会进行下一次脏检查循环，也就不会运行已注册的延时运行函数。同时，如果$evalAsync总是在watchFn中被调用，那么异步队列总不为空，脏检查循环次数达到上限后，需要抛出异常。

10.$evalAsync异步运行函数，需要检查当前的状态，是否脏检查循环已经开始运行，如果没有运行的话就要开始脏检查循环，以便可以尽快运行异步函数，因此，需要给scope一个状态量$$phase.

11.$applyAsyncy异步运行函数对外接口，主要是为Http服务的，在页面初始化的时候会进行一系列的Http请求，对于每个相应都有一次昂贵的脏检查循环，可以让两次相隔很近的Http响应，合并成单个的脏检查循环。在监视函数中调用$applyAsync可以延时运行函数，并不会在当前脏检查循环时调用延时函数。

12.$$postDigest注册的函数将在脏检查循环后执行，传入$$postDigest的循环后运行函数没有任何参数，也不会传入scope作为其参数，且在其中改变scope中的值也不会触发脏检查循环。

13.异常控制。在监视器中，监视函数和监听函数有可能发生，一旦发生异常，应该进行异常记录后继续检查下一个控制器。

14.销毁监视器。$watch函数有一个返回函数，调用这个返回函数即可销毁注册的监视器。在脏检查的时候销毁监视器，会使得跳过下一个监视器，可以采用一个巧妙的办法，每次将监视器从前面添加进队列，脏检查的时候从队列的后面进行循环，这样就不会跳过下一个控制器了。

总结： 
1.两个脏检查循环的重要过程：$watch注册监视器，$digest进行脏检查循环；
2.脏检查循环次数达到上限，则会抛出一个异常；
3.基于值比较和基于引用的比较是不同的；
4.在脏检查循环中执行函数有很多种方法，直接执行$eval,$apply，延时执行$evalAsync,$applyAsync,$$postDigest
5.脏检查循环中的异常处理，异常可能发生在监视函数或者监听函数中，不应该影响到其他控制器的运行；
6.通过$watch函数可以返回一个监视器销毁函数；
7.可以通过$watchGroup监视一系列的变量，运行同一个监听函数。